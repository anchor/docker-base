#!/bin/sh
set +x
set +e

#
# Parameter documentation, called on init error
#

show_help() {
	echo "Usage: $0 [options]

	-n|--name                  -- Name of created docker image
	-d|--docker_registry       -- Docker Registry              Defaults to https://registry.hub.docker.com
	-o|--docker_opts           -- Docker options               Optional
	-g|--git_branch            -- Git branch for artifacts     Defaults to master
	-v|--version               -- Version                      Defaults to \$GIT_COMMIT

	# Docker image options - provide either
	-b|--docker_build_image    -- Image for buidling
	-r|--docker_release_image  -- Image for releasing
	# or just one
	-i|--docker_image          -- Image for both building and releasing
	#format: image:tag
	"
	exit 0
}


#
# Called on first require, to setup command line vars, and folder structure
#

build_init () {
	mkdir -p cache/stamp
	mkdir -p src/.cabal

	while [ "$#" != "0" ]
	do
		key="$1"
		shift
		case $key in
			-n|--name) NAME=$1; shift;;
			-v|--version) VERSION=$1; shift;;
			-d|--docker_registry) DOCKER_REGISTRY=$; shift;;
			-o|--docker_opts) DOCKER_OPTS=$1; shift;;
			-b|--docker_build_image) DOCKER_BUILD=$1; shift;;
			-r|--docker_release_image) DOCKER_RELEASE=$1; shift;;
			-i|--docker_image) DOCKER_IMAGE=$1; shift;;
			-g|--git_branch) GIT_BRANCH=$1; shift;;
			-?|-h ) show_help; shift;;
		esac
	done

	# Default branch is 'master'
	if [ -z "$GIT_BRANCH" ]; then
		GIT_BRANCH="master"
	fi

	# If using the Jenkins-style $GIT_BRANCH format ("repo/branch"), retrieve just the branch.
	case "$GIT_BRANCH" in
		*/* ) GIT_BRANCH=`echo $GIT_BRANCH | cut -d'/' -f2`;;
	esac

	# Must provide at least DOCKER_(RELEASE|BUILD)_IMAGE or DOCKER_IMAGE
	if [ -z "$DOCKER_RELEASE" -a -z "$DOCKER_BUILD" -a -z "$DOCKER_IMAGE" ]; then
		show_help
	fi

	# If using just one image, fill the other two with items.
	if [ -z "$DOCKER_RELEASE" -a -z "$DOCKER_BUILD" -a -n "$DOCKER_IMAGE" ]; then
		DOCKER_RELEASE=$DOCKER_IMAGE
		DOCKER_BUILD=$DOCKER_IMAGE
	fi

	# If using the main docker registry, don't include the slash in the name.
	# e.g. centos vs myregistry.com/centos
	if [ -n "$DOCKER_REGISTRY" ]; then
		DOCKER_RELEASE_IMAGE=$DOCKER_RELEASE
		DOCKER_BUILD_IMAGE=$DOCKER_BUILD
	else
		DOCKER_RELEASE_IMAGE="$DOCKER_REGISTRY/$DOCKER_RELEASE"
		DOCKER_BUILD_IMAGE="$DOCKER_REGISTRY/$DOCKER_BUILD"
	fi

	# Use predefined $GIT_COMMIT, or find our own
	if [ -z "$VERSION" ]; then
		if [ -z "$GIT_COMMIT" ]; then
			VERSION=$(git show-ref refs/heads/master | awk '{print $1}')
		else
			VERSION=$GIT_COMMIT
		fi
	fi

	# Error out if any mandatory parameters were missed
	if [ -z "$NAME" -o -z "$VERSION" ]; then
		show_help
	fi

	echo "This build will be using:
		GIT_BRANCH:           $GIT_BRANCH
		DOCKER_BUILD_IMAGE:   $DOCKER_BUILD_IMAGE
		DOCKER_RELEASE_IMAGE: $DOCKER_RELEASE_IMAGE
		VERISON:              $VERSION
	"
}


#
# Install a base system
#

initialize () {

	if [ -f cache/stamp/initialize ] ; then
		return
	fi

	IMAGE_NAME="${NAME}-${GIT_BRANCH}-${VERSION}"
	REPO="cache/${NAME}"

	rsync -a src/ cache

	docker $DOCKER_OPTS pull $DOCKER_RELEASE_IMAGE
	docker $DOCKER_OPTS pull $DOCKER_BUILD_IMAGE
	touch cache/stamp/initialize
}


baseline () {
	if [ cache/stamp/baseline -nt cache/stamp/initalize ] ; then
		return
	fi

	# Kill the container if it's already running.
	docker $DOCKER_OPTS stop "$IMAGE_NAME" || true
	docker $DOCKER_OPTS rm "$IMAGE_NAME" || true

	docker $DOCKER_OPTS run --name="$IMAGE_NAME" -t \
		-v ${PWD}/cache:/src:rw \
		"$DOCKER_BUILD_IMAGE" \
		src/baseline
	RC=$(docker $DOCKER_OPTS wait "$IMAGE_NAME")
	if [ $RC -ne 0 ]; then
		echo "Build returned nonzero exit status, bailing out."
	fi
	docker $DOCKER_OPTS commit "$IMAGE_NAME" "$DOCKER_REGISTRY/engineering/${NAME}:baseline"
	docker $DOCKER_OPTS rm "$IMAGE_NAME"

	touch cache/stamp/baseline
}


#
# Update (or initally clone) source code and build objects in volume
#

objects () {
	if [ cache/stamp/objects -nt cache/stamp/baseline ] ; then
		return
	fi
	echo docker $DOCKER_OPTS run --name="$IMAGE_NAME" -t -v ${PWD}/cache:/src:rw $DOCKER_REGISTRY/engineering/${NAME}:baseline src/objects
	docker $DOCKER_OPTS run --name="$IMAGE_NAME" -t -v ${PWD}/cache:/src:rw $DOCKER_REGISTRY/engineering/${NAME}:baseline src/objects

	RC=$(docker $DOCKER_OPTS wait "$IMAGE_NAME")
	if [ $RC -ne 0 ]; then
		echo "Build returned nonzero exit status, bailing out."
	fi
	docker $DOCKER_OPTS commit "$IMAGE_NAME" "$DOCKER_REGISTRY/engineering/${NAME}:objects"
	docker $DOCKER_OPTS rm "$IMAGE_NAME"

	touch cache/stamp/objects
}


#
# Extract the binary artifacts
#

release () {
	if [ cache/stamp/release -nt cache/stamp/objects ] ; then
		return
	fi
	docker $DOCKER_OPTS run --name="$IMAGE_NAME" -t -v ${PWD}/cache:/src:rw $DOCKER_RELEASE_IMAGE src/release
	RC=$(docker $DOCKER_OPTS wait "$IMAGE_NAME")
	if [ $RC -ne 0 ]; then
		echo "Build returned nonzero exit status, bailing out."
	fi
	docker $DOCKER_OPTS commit "$IMAGE_NAME" "$DOCKER_REGISTRY/engineering/${NAME}:${VERSION}"
	docker $DOCKER_OPTS rm "$IMAGE_NAME"
	touch cache/stamp/release
}

#
#
#

publish () {
	if [ cache/stamp/publish -nt cache/stamp/release ] ; then
		return
	fi
	BUILD=$VERSION
	# Tag the built image with the SHA from the software repo.
	docker $DOCKER_OPTS tag "$DOCKER_REGISTRY/engineering/${NAME}:${VERSION}" \
		"$DOCKER_REGISTRY/engineering/${NAME}:${BUILD}"

	if [ "$GIT_BRANCH" = "master" ]; then
		# Tag the built image with "latest".
		echo "Pushing a master branch build to docker as '$NAME:latest'"
		docker $DOCKER_OPTS tag "$DOCKER_REGISTRY/engineering/${NAME}:${VERSION}" \
			"$DOCKER_REGISTRY/engineering/${NAME}:latest"
		docker $DOCKER_OPTS push "$DOCKER_REGISTRY/engineering/${NAME}:latest"
	else
		# Tag the built image with the branch.
		echo "Pushing the topic branch $GIT_BRANCH to docker as '$NAME:$GIT_BRANCH'"
		docker $DOCKER_OPTS tag "$DOCKER_REGISTRY/engineering/${NAME}:${VERSION}" \
			"$DOCKER_REGISTRY/engineering/${NAME}:${GIT_BRANCH}"
		docker $DOCKER_OPTS push "$DOCKER_REGISTRY/engineering/${NAME}:${GIT_BRANCH}"
	fi

	docker $DOCKER_OPTS push "$DOCKER_REGISTRY/engineering/${NAME}:${BUILD}"

	touch cache/stamp/publish
}

haddock () {
	tar -czf ${NAME}-documentation.tar.gz cache/.cabal/share/doc
}

build_init
